diff --git a/packages/features/bookings/lib/handleNewBooking.ts b/packages/features/bookings/lib/handleNewBooking.ts
index 32ba96837..d6bbe78a5 100644
--- a/packages/features/bookings/lib/handleNewBooking.ts
+++ b/packages/features/bookings/lib/handleNewBooking.ts
@@ -1,13 +1,14 @@
-import type { App, Credential, EventTypeCustomInput } from "@prisma/client";
+import type { App, Attendee, Credential, EventTypeCustomInput } from "@prisma/client";
 import { BookingStatus, SchedulingType, WebhookTriggerEvents, WorkflowMethods, Prisma } from "@prisma/client";
 import async from "async";
 import { isValidPhoneNumber } from "libphonenumber-js";
 import { cloneDeep } from "lodash";
 import type { NextApiRequest } from "next";
-import short from "short-uuid";
+import short, { uuid } from "short-uuid";
 import { v5 as uuidv5 } from "uuid";
 import z from "zod";
 
+import { getCalendar } from "@calcom/app-store/_utils/getCalendar";
 import { metadata as GoogleMeetMetadata } from "@calcom/app-store/googlevideo/_metadata";
 import type { LocationObject } from "@calcom/app-store/locations";
 import { getLocationValueForDB } from "@calcom/app-store/locations";
@@ -19,6 +20,7 @@ import { cancelScheduledJobs, scheduleTrigger } from "@calcom/app-store/zapier/l
 import EventManager from "@calcom/core/EventManager";
 import { getEventName } from "@calcom/core/event";
 import { getUserAvailability } from "@calcom/core/getUserAvailability";
+import { deleteMeeting } from "@calcom/core/videoClient";
 import type { ConfigType, Dayjs } from "@calcom/dayjs";
 import dayjs from "@calcom/dayjs";
 import {
@@ -26,6 +28,7 @@ import {
   sendOrganizerRequestEmail,
   sendRescheduledEmails,
   sendScheduledEmails,
+  sendRescheduledSeatEmail,
   sendScheduledSeatsEmails,
 } from "@calcom/emails";
 import { getBookingFieldsWithSystemFields } from "@calcom/features/bookings/lib/getBookingFields";
@@ -49,6 +52,7 @@ import { slugify } from "@calcom/lib/slugify";
 import { updateWebUser as syncServicesUpdateWebUser } from "@calcom/lib/sync/SyncServiceManager";
 import { TimeFormat } from "@calcom/lib/timeFormat";
 import prisma, { userSelect } from "@calcom/prisma";
+import type { BookingReference } from "@calcom/prisma/client";
 import type { bookingCreateSchemaLegacyPropsForApi } from "@calcom/prisma/zod-utils";
 import {
   bookingCreateBodySchemaForApi,
@@ -58,7 +62,7 @@ import {
   userMetadata as userMetadataSchema,
 } from "@calcom/prisma/zod-utils";
 import type { BufferedBusyTime } from "@calcom/types/BufferedBusyTime";
-import type { AdditionalInformation, AppsStatus, CalendarEvent } from "@calcom/types/Calendar";
+import type { AdditionalInformation, AppsStatus, CalendarEvent, Person } from "@calcom/types/Calendar";
 import type { EventResult, PartialReference } from "@calcom/types/EventManager";
 import type { WorkingHours } from "@calcom/types/schedule";
 
@@ -326,6 +330,40 @@ async function ensureAvailableUsers(
   return availableUsers;
 }
 
+async function getOriginalRescheduledBooking(uid: string, seatsEventType?: boolean) {
+  return prisma.booking.findFirst({
+    where: {
+      uid: uid,
+      status: {
+        in: [BookingStatus.ACCEPTED, BookingStatus.CANCELLED, BookingStatus.PENDING],
+      },
+    },
+    include: {
+      attendees: {
+        select: {
+          name: true,
+          email: true,
+          locale: true,
+          timeZone: true,
+          ...(seatsEventType && { bookingSeat: true, id: true }),
+        },
+      },
+      user: {
+        select: {
+          id: true,
+          name: true,
+          email: true,
+          locale: true,
+          timeZone: true,
+        },
+      },
+      payment: true,
+      references: true,
+      workflowReminders: true,
+    },
+  });
+}
+
 function getBookingData({
   req,
   isNotAnApiCall,
@@ -638,7 +676,7 @@ async function handler(
   await handleEthSignature(rainbowAppData, reqBody.ethSignature);
 
   const [organizerUser] = users;
-  const tOrganizer = await getTranslation(organizerUser.locale ?? "en", "common");
+  const tOrganizer = await getTranslation(organizerUser?.locale ?? "en", "common");
 
   const invitee = [
     {
@@ -758,46 +796,38 @@ async function handler(
     seatsPerTimeSlot: eventType.seatsPerTimeSlot,
   };
 
-  // For seats, if the booking already exists then we want to add the new attendee to the existing booking
-  if (reqBody.bookingUid) {
-    if (!eventType.seatsPerTimeSlot) {
-      throw new HttpError({ statusCode: 404, message: "Event type does not have seats" });
-    }
+  let rescheduleUid = reqBody.rescheduleUid;
+  let bookingSeat: Prisma.BookingSeatGetPayload<{ include: { booking: true; attendee: true } }> | null = null;
+  type BookingType = Prisma.PromiseReturnType<typeof getOriginalRescheduledBooking>;
+  let originalRescheduledBooking: BookingType = null;
 
-    const booking = await prisma.booking.findUnique({
+  if (rescheduleUid) {
+    // rescheduleUid can be bookingUid and bookingSeatUid
+    bookingSeat = await prisma.bookingSeat.findUnique({
       where: {
-        uid: reqBody.bookingUid,
+        referenceUid: rescheduleUid,
       },
-      select: {
-        uid: true,
-        id: true,
-        attendees: true,
-        userId: true,
-        references: true,
-        startTime: true,
-        user: true,
+      include: {
+        booking: true,
+        attendee: true,
       },
     });
-    if (!booking) {
-      throw new HttpError({ statusCode: 404, message: "Booking not found" });
+    if (bookingSeat) {
+      bookingSeat = bookingSeat;
+      rescheduleUid = bookingSeat.booking.uid;
     }
-
-    // Need to add translation for attendees to pass type checks. Since these values are never written to the db we can just use the new attendee language
-    const bookingAttendees = booking.attendees.map((attendee) => {
-      return { ...attendee, language: { translate: tAttendees, locale: language ?? "en" } };
-    });
-
-    evt = { ...evt, attendees: [...bookingAttendees, invitee[0]] };
-
-    if (eventType.seatsPerTimeSlot <= booking.attendees.length) {
-      throw new HttpError({ statusCode: 409, message: "Booking seats are full" });
-    }
-
-    if (booking.attendees.find((attendee) => attendee.email === invitee[0].email)) {
-      throw new HttpError({ statusCode: 409, message: "Already signed up for time slot" });
+    originalRescheduledBooking = await getOriginalRescheduledBooking(
+      rescheduleUid,
+      !!eventType.seatsPerTimeSlot
+    );
+    if (!originalRescheduledBooking) {
+      throw new HttpError({ statusCode: 404, message: "Could not find original booking" });
     }
+  }
 
-    const videoCallReference = booking.references.find((reference) => reference.type.includes("_video"));
+  /* Used for seats bookings to update evt object with video data */
+  const addVideoCallDataToEvt = (bookingReferences: BookingReference[]) => {
+    const videoCallReference = bookingReferences.find((reference) => reference.type.includes("_video"));
 
     if (videoCallReference) {
       evt.videoCallData = {
@@ -807,84 +837,552 @@ async function handler(
         url: videoCallReference.meetingUrl,
       };
     }
-    await prisma.booking.update({
+  };
+
+  /* Check if the original booking has no more attendees, if so delete the booking
+  and any calendar or video integrations */
+  const lastAttendeeDeleteBooking = async (
+    originalRescheduledBooking: Awaited<ReturnType<typeof getOriginalRescheduledBooking>>,
+    filteredAttendees: Partial<Attendee>[],
+    originalBookingEvt?: CalendarEvent
+  ) => {
+    let deletedReferences = false;
+    if (filteredAttendees && filteredAttendees.length === 0 && originalRescheduledBooking) {
+      const integrationsToDelete = [];
+
+      for (const reference of originalRescheduledBooking.references) {
+        if (reference.credentialId) {
+          const credential = await prisma.credential.findUnique({
+            where: {
+              id: reference.credentialId,
+            },
+          });
+
+          if (credential) {
+            if (reference.type.includes("_video")) {
+              integrationsToDelete.push(deleteMeeting(credential, reference.uid));
+            }
+            if (reference.type.includes("_calendar") && originalBookingEvt) {
+              const calendar = getCalendar(credential);
+              if (calendar) {
+                integrationsToDelete.push(
+                  calendar?.deleteEvent(reference.uid, originalBookingEvt, reference.externalCalendarId)
+                );
+              }
+            }
+          }
+        }
+      }
+
+      await Promise.all(integrationsToDelete).then(async () => {
+        await prisma.booking.delete({
+          where: {
+            id: originalRescheduledBooking.id,
+          },
+        });
+      });
+      deletedReferences = true;
+    }
+    return deletedReferences;
+  };
+
+  const handleSeats = async (): Promise<
+    | (Partial<Booking> & {
+        appsStatus?: AppsStatus[];
+        seatReferenceUid?: string;
+        paymentUid?: string;
+        message?: string;
+      })
+    | null
+  > => {
+    const booking = await prisma.booking.findUniqueOrThrow({
       where: {
-        uid: reqBody.bookingUid,
+        uid: rescheduleUid || reqBody.bookingUid,
       },
-      data: {
-        attendees: {
-          create: {
-            email: invitee[0].email,
-            name: invitee[0].name,
-            timeZone: invitee[0].timeZone,
-            locale: invitee[0].language.locale,
-          },
-        },
+      select: {
+        uid: true,
+        id: true,
+        attendees: { include: { bookingSeat: true } },
+        userId: true,
+        references: true,
+        startTime: true,
+        user: true,
+        status: true,
       },
     });
+    // See if attendee is already signed up for timeslot
+    if (
+      booking.attendees.find((attendee) => attendee.email === invitee[0].email) &&
+      dayjs.utc(booking.startTime).format() === evt.startTime
+    ) {
+      throw new HttpError({ statusCode: 409, message: "Already signed up for this booking." });
+    }
 
-    const newSeat = booking.attendees.length !== 0;
-
-    /**
-     * Remember objects are passed into functions as references
-     * so if you modify it in a inner function it will be modified in the outer function
-     * deep cloning evt to avoid this
-     */
-    const copyEvent = cloneDeep(evt);
-    await sendScheduledSeatsEmails(copyEvent, invitee[0], newSeat, !!eventType.seatsShowAttendees);
+    // There are two paths here, reschedule a booking with seats and booking seats without reschedule
+    if (rescheduleUid) {
+      const seatAttendee: Partial<Person> | null = bookingSeat?.attendee || null;
+      // Required for Typescript, these should always be set.
+      if (!seatAttendee || !bookingSeat || !rescheduleUid) {
+        throw new Error("Internal Error.");
+      }
 
-    const credentials = await refreshCredentials(organizerUser.credentials);
-    const eventManager = new EventManager({ ...organizerUser, credentials });
-    await eventManager.updateCalendarAttendees(evt, booking);
+      seatAttendee.language = { translate: tAttendees, locale: bookingSeat?.attendee.locale ?? "en" };
 
-    if (!Number.isNaN(paymentAppData.price) && paymentAppData.price > 0 && !!booking) {
-      const credentialPaymentAppCategories = await prisma.credential.findMany({
+      // See if the new date has a booking already
+      const newTimeSlotBooking = await prisma.booking.findFirst({
         where: {
-          userId: organizerUser.id,
-          app: {
-            categories: {
-              hasSome: ["payment"],
-            },
-          },
+          startTime: evt.startTime,
+          eventTypeId: eventType.id,
         },
         select: {
-          key: true,
-          appId: true,
-          app: {
-            select: {
-              categories: true,
-              dirName: true,
+          id: true,
+          uid: true,
+          attendees: {
+            include: {
+              bookingSeat: true,
             },
           },
         },
       });
 
-      const eventTypePaymentAppCredential = credentialPaymentAppCategories.find((credential) => {
-        return credential.appId === paymentAppData.appId;
+      const credentials = await refreshCredentials(organizerUser.credentials);
+      const eventManager = new EventManager({ ...organizerUser, credentials });
+
+      if (!originalRescheduledBooking) {
+        // typescript isn't smart enough;
+        throw new Error("Internal Error.");
+      }
+
+      const updatedBookingAttendees = originalRescheduledBooking.attendees.reduce(
+        (filteredAttendees, attendee) => {
+          if (attendee.email === bookerEmail) {
+            return filteredAttendees; // skip current booker, as we know the language already.
+          }
+          filteredAttendees.push({
+            name: attendee.name,
+            email: attendee.email,
+            timeZone: attendee.timeZone,
+            language: { translate: tAttendees, locale: attendee.locale ?? "en" },
+          });
+          return filteredAttendees;
+        },
+        [] as Person[]
+      );
+
+      // If original booking has video reference we need to add the videoCallData to the new evt
+      const videoReference = originalRescheduledBooking.references.find((reference) =>
+        reference.type.includes("_video")
+      );
+
+      const originalBookingEvt = {
+        ...evt,
+        title: originalRescheduledBooking.title,
+        startTime: dayjs(originalRescheduledBooking.startTime).utc().format(),
+        endTime: dayjs(originalRescheduledBooking.endTime).utc().format(),
+        attendees: updatedBookingAttendees,
+        // If the location is a video integration then include the videoCallData
+        ...(videoReference && {
+          videoCallData: {
+            type: videoReference.type,
+            id: videoReference.meetingId,
+            password: videoReference.meetingPassword,
+            url: videoReference.meetingUrl,
+          },
+        }),
+      };
+
+      // If owner reschedules the event we want to update the entire booking
+      // Also if owner is rescheduling there should be no bookingSeat
+      if (booking.user?.id === req.userId && !bookingSeat) {
+        // If there is no booking during the new time slot then update the current booking to the new date
+        if (!newTimeSlotBooking) {
+          const newBooking: (Booking & { appsStatus?: AppsStatus[] }) | null = await prisma.booking.update({
+            where: {
+              id: booking.id,
+            },
+            data: {
+              startTime: evt.startTime,
+              cancellationReason: rescheduleReason,
+            },
+            include: {
+              user: true,
+              references: true,
+              payment: true,
+              attendees: true,
+            },
+          });
+
+          addVideoCallDataToEvt(newBooking.references);
+
+          const copyEvent = cloneDeep(evt);
+
+          const updateManager = await eventManager.reschedule(copyEvent, rescheduleUid, newBooking.id);
+
+          // @NOTE: This code is duplicated and should be moved to a function
+          // This gets overridden when updating the event - to check if notes have been hidden or not. We just reset this back
+          // to the default description when we are sending the emails.
+          evt.description = eventType.description;
+
+          const results = updateManager.results;
+
+          if (results.length > 0 && results.some((res) => !res.success)) {
+            const error = {
+              errorCode: "BookingReschedulingMeetingFailed",
+              message: "Booking Rescheduling failed",
+            };
+            log.error(`Booking ${organizerUser.name} failed`, error, results);
+          } else {
+            const metadata: AdditionalInformation = {};
+            if (results.length) {
+              // TODO: Handle created event metadata more elegantly
+              const [updatedEvent] = Array.isArray(results[0].updatedEvent)
+                ? results[0].updatedEvent
+                : [results[0].updatedEvent];
+              if (updatedEvent) {
+                metadata.hangoutLink = updatedEvent.hangoutLink;
+                metadata.conferenceData = updatedEvent.conferenceData;
+                metadata.entryPoints = updatedEvent.entryPoints;
+                handleAppsStatus(results, newBooking);
+              }
+            }
+          }
+
+          if (noEmail !== true) {
+            const copyEvent = cloneDeep(evt);
+            await sendRescheduledEmails({
+              ...copyEvent,
+              additionalNotes, // Resets back to the additionalNote input and not the override value
+              cancellationReason: "$RCH$" + rescheduleReason, // Removable code prefix to differentiate cancellation from rescheduling for email
+            });
+          }
+          const resultBooking = await resultBookingQuery(newBooking.id);
+
+          return { ...resultBooking, appsStatus: newBooking.appsStatus };
+        }
+
+        // Merge two bookings together
+        const attendeesToMove = [],
+          attendeesToDelete = [];
+
+        for (const attendee of booking.attendees) {
+          // If the attendee already exists on the new booking then delete the attendee record of the old booking
+          if (
+            newTimeSlotBooking.attendees.some(
+              (newBookingAttendee) => newBookingAttendee.email === attendee.email
+            )
+          ) {
+            attendeesToDelete.push(attendee.id);
+            // If the attendee does not exist on the new booking then move that attendee record to the new booking
+          } else {
+            attendeesToMove.push({ id: attendee.id, seatReferenceId: attendee.bookingSeat?.id });
+          }
+        }
+
+        // Confirm that the new event will have enough available seats
+        if (
+          !eventType.seatsPerTimeSlot ||
+          attendeesToMove.length +
+            newTimeSlotBooking.attendees.filter((attendee) => attendee.bookingSeat).length >
+            eventType.seatsPerTimeSlot
+        ) {
+          throw new HttpError({ statusCode: 409, message: "Booking does not have enough available seats" });
+        }
+
+        const moveAttendeeCalls = [];
+        for (const attendeeToMove of attendeesToMove) {
+          moveAttendeeCalls.push(
+            prisma.attendee.update({
+              where: {
+                id: attendeeToMove.id,
+              },
+              data: {
+                bookingId: newTimeSlotBooking.id,
+                bookingSeat: {
+                  upsert: {
+                    create: {
+                      referenceUid: uuid(),
+                      bookingId: newTimeSlotBooking.id,
+                    },
+                    update: {
+                      bookingId: newTimeSlotBooking.id,
+                    },
+                  },
+                },
+              },
+            })
+          );
+        }
+
+        await Promise.all([
+          ...moveAttendeeCalls,
+          // Delete any attendees that are already a part of that new time slot booking
+          prisma.attendee.deleteMany({
+            where: {
+              id: {
+                in: attendeesToDelete,
+              },
+            },
+          }),
+        ]);
+
+        const updatedNewBooking = await prisma.booking.findUnique({
+          where: {
+            id: newTimeSlotBooking.id,
+          },
+          include: {
+            attendees: true,
+            references: true,
+          },
+        });
+
+        if (!updatedNewBooking) {
+          throw new HttpError({ statusCode: 404, message: "Updated booking not found" });
+        }
+
+        // Update the evt object with the new attendees
+        const updatedBookingAttendees = updatedNewBooking.attendees.map((attendee) => {
+          const evtAttendee = { ...attendee, language: { translate: tAttendees, locale: language ?? "en" } };
+          return evtAttendee;
+        });
+
+        evt.attendees = updatedBookingAttendees;
+
+        addVideoCallDataToEvt(updatedNewBooking.references);
+
+        const copyEvent = cloneDeep(evt);
+
+        await eventManager.reschedule(copyEvent, rescheduleUid, newTimeSlotBooking.id);
+
+        // TODO send reschedule emails to attendees of the old booking
+        await sendRescheduledEmails({
+          ...copyEvent,
+          additionalNotes, // Resets back to the additionalNote input and not the override value
+          cancellationReason: "$RCH$" + rescheduleReason, // Removable code prefix to differentiate cancellation from rescheduling for email
+        });
+
+        // Delete the old booking
+        await prisma.booking.delete({
+          where: {
+            id: booking.id,
+          },
+        });
+
+        const resultBooking = await resultBookingQuery(newTimeSlotBooking.id);
+
+        return { ...resultBooking };
+      }
+
+      // If there is no booking then remove the attendee from the old booking and create a new one
+      if (!newTimeSlotBooking) {
+        await prisma.bookingSeat.delete({
+          where: {
+            id: bookingSeat.id,
+          },
+        });
+
+        await prisma.attendee.delete({
+          where: {
+            id: seatAttendee.id,
+          },
+        });
+
+        // Update the original calendar event by removing the attendee that is rescheduling
+        if (originalBookingEvt && originalRescheduledBooking) {
+          // Event would probably be deleted so we first check than instead of updating references
+          const filteredAttendees = originalRescheduledBooking?.attendees.filter((attendee) => {
+            return attendee.email !== bookerEmail;
+          });
+          const deletedReference = await lastAttendeeDeleteBooking(
+            originalRescheduledBooking,
+            filteredAttendees,
+            originalBookingEvt
+          );
+
+          if (!deletedReference) {
+            await eventManager.updateCalendarAttendees(originalBookingEvt, originalRescheduledBooking);
+          }
+        }
+
+        // We don't want to trigger rescheduling logic of the original booking
+        originalRescheduledBooking = null;
+
+        return null;
+      }
+
+      // Need to change the new seat reference and attendee record to remove it from the old booking and add it to the new booking
+      // https://stackoverflow.com/questions/4980963/database-insert-new-rows-or-update-existing-ones
+      await Promise.all([
+        await prisma.attendee.update({
+          where: {
+            id: seatAttendee.id,
+          },
+          data: {
+            bookingId: newTimeSlotBooking.id,
+          },
+        }),
+        await prisma.bookingSeat.update({
+          where: {
+            id: bookingSeat.id,
+          },
+          data: {
+            bookingId: newTimeSlotBooking.id,
+          },
+        }),
+      ]);
+
+      const copyEvent = cloneDeep(evt);
+
+      await eventManager.reschedule(copyEvent, rescheduleUid, newTimeSlotBooking.id);
+
+      await sendRescheduledSeatEmail(copyEvent, seatAttendee as Person);
+      const filteredAttendees = originalRescheduledBooking?.attendees.filter((attendee) => {
+        return attendee.email !== bookerEmail;
       });
+      await lastAttendeeDeleteBooking(originalRescheduledBooking, filteredAttendees, originalBookingEvt);
 
-      if (!eventTypePaymentAppCredential) {
-        throw new HttpError({ statusCode: 400, message: "Missing payment credentials" });
+      const resultBooking = await resultBookingQuery(newTimeSlotBooking.id);
+
+      return { ...resultBooking, seatReferenceUid: bookingSeat.referenceUid };
+    } else {
+      // Need to add translation for attendees to pass type checks. Since these values are never written to the db we can just use the new attendee language
+      const bookingAttendees = booking.attendees.map((attendee) => {
+        return { ...attendee, language: { translate: tAttendees, locale: language ?? "en" } };
+      });
+
+      evt = { ...evt, attendees: [...bookingAttendees, invitee[0]] };
+
+      if (eventType.seatsPerTimeSlot && eventType.seatsPerTimeSlot <= booking.attendees.length) {
+        throw new HttpError({ statusCode: 409, message: "Booking seats are full" });
       }
-      if (!eventTypePaymentAppCredential?.appId) {
-        throw new HttpError({ statusCode: 400, message: "Missing payment app id" });
+
+      const videoCallReference = booking.references.find((reference) => reference.type.includes("_video"));
+
+      if (videoCallReference) {
+        evt.videoCallData = {
+          type: videoCallReference.type,
+          id: videoCallReference.meetingId,
+          password: videoCallReference?.meetingPassword,
+          url: videoCallReference.meetingUrl,
+        };
       }
 
-      const payment = await handlePayment(
-        evt,
-        eventType,
-        eventTypePaymentAppCredential as IEventTypePaymentCredentialType,
-        booking
-      );
+      const bookingUpdated = await prisma.booking.update({
+        where: {
+          uid: reqBody.bookingUid,
+        },
+        include: {
+          attendees: true,
+        },
+        data: {
+          attendees: {
+            create: {
+              email: invitee[0].email,
+              name: invitee[0].name,
+              timeZone: invitee[0].timeZone,
+              locale: invitee[0].language.locale,
+            },
+          },
+          ...(booking.status === BookingStatus.CANCELLED && { status: BookingStatus.ACCEPTED }),
+        },
+      });
+
+      // Add entry to bookingSeat table
+      const attendeeUniqueId = uuid();
+      await prisma.bookingSeat.create({
+        data: {
+          data: {
+            description: additionalNotes,
+          },
+          booking: {
+            connect: {
+              id: booking.id,
+            },
+          },
+          referenceUid: attendeeUniqueId,
+          attendee: {
+            connect: {
+              id: bookingUpdated.attendees[bookingUpdated.attendees.length - 1].id,
+            },
+          },
+        },
+      });
+      evt.attendeeSeatId = attendeeUniqueId;
+
+      const newSeat = booking.attendees.length !== 0;
+
+      /**
+       * Remember objects are passed into functions as references
+       * so if you modify it in a inner function it will be modified in the outer function
+       * deep cloning evt to avoid this
+       */
+      const copyEvent = cloneDeep(evt);
+      await sendScheduledSeatsEmails(copyEvent, invitee[0], newSeat, !!eventType.seatsShowAttendees);
 
+      const credentials = await refreshCredentials(organizerUser.credentials);
+      const eventManager = new EventManager({ ...organizerUser, credentials });
+      await eventManager.updateCalendarAttendees(evt, booking);
+
+      const resultBooking = await resultBookingQuery(booking.id);
+
+      if (!Number.isNaN(paymentAppData.price) && paymentAppData.price > 0 && !!booking) {
+        const credentialPaymentAppCategories = await prisma.credential.findMany({
+          where: {
+            userId: organizerUser.id,
+            app: {
+              categories: {
+                hasSome: ["payment"],
+              },
+            },
+          },
+          select: {
+            key: true,
+            appId: true,
+            app: {
+              select: {
+                categories: true,
+                dirName: true,
+              },
+            },
+          },
+        });
+
+        const eventTypePaymentAppCredential = credentialPaymentAppCategories.find((credential) => {
+          return credential.appId === paymentAppData.appId;
+        });
+
+        if (!eventTypePaymentAppCredential) {
+          throw new HttpError({ statusCode: 400, message: "Missing payment credentials" });
+        }
+        if (!eventTypePaymentAppCredential?.appId) {
+          throw new HttpError({ statusCode: 400, message: "Missing payment app id" });
+        }
+
+        const payment = await handlePayment(
+          evt,
+          eventType,
+          eventTypePaymentAppCredential as IEventTypePaymentCredentialType,
+          booking
+        );
+
+        return {
+          ...resultBooking,
+          message: "Payment required",
+          paymentUid: payment?.uid,
+          seatReferenceUid: bookingSeat?.referenceUid,
+        };
+      }
+
+      return { ...resultBooking, seatReferenceUid: evt.attendeeSeatId };
+    }
+  };
+  // For seats, if the booking already exists then we want to add the new attendee to the existing booking
+  if (eventType.seatsPerTimeSlot && (reqBody.bookingUid || rescheduleUid)) {
+    const newBooking = await handleSeats();
+    if (newBooking) {
       req.statusCode = 201;
-      return { ...booking, message: "Payment required", paymentUid: payment?.uid };
+      return newBooking;
     }
-
-    req.statusCode = 201;
-    return booking;
   }
-
   if (isTeamEventType) {
     evt.team = {
       members: teamMembers,
@@ -899,45 +1397,6 @@ async function handler(
     evt.recurringEvent = eventType.recurringEvent;
   }
 
-  // Initialize EventManager with credentials
-  const rescheduleUid = reqBody.rescheduleUid;
-  async function getOriginalRescheduledBooking(uid: string) {
-    return prisma.booking.findFirst({
-      where: {
-        uid,
-        status: {
-          in: [BookingStatus.ACCEPTED, BookingStatus.CANCELLED, BookingStatus.PENDING],
-        },
-      },
-      include: {
-        attendees: {
-          select: {
-            name: true,
-            email: true,
-            locale: true,
-            timeZone: true,
-          },
-        },
-        user: {
-          select: {
-            id: true,
-            name: true,
-            email: true,
-            locale: true,
-            timeZone: true,
-          },
-        },
-        payment: true,
-        workflowReminders: true,
-      },
-    });
-  }
-
-  type BookingType = Prisma.PromiseReturnType<typeof getOriginalRescheduledBooking>;
-  let originalRescheduledBooking: BookingType = null;
-  if (rescheduleUid) {
-    originalRescheduledBooking = await getOriginalRescheduledBooking(rescheduleUid);
-  }
   // If the user is not the owner of the event, new booking should be always pending.
   // Otherwise, an owner rescheduling should be always accepted.
   // Before comparing make sure that userId is set, otherwise undefined === undefined
@@ -948,7 +1407,7 @@ async function handler(
     if (originalRescheduledBooking) {
       evt.title = originalRescheduledBooking?.title || evt.title;
       evt.description = originalRescheduledBooking?.description || evt.additionalNotes;
-      evt.location = originalRescheduledBooking?.location;
+      evt.location = originalRescheduledBooking?.location || evt.location;
     }
 
     const eventTypeRel = !eventTypeId
@@ -962,6 +1421,24 @@ async function handler(
     const dynamicEventSlugRef = !eventTypeId ? eventTypeSlug : null;
     const dynamicGroupSlugRef = !eventTypeId ? (reqBody.user as string).toLowerCase() : null;
 
+    // If the user is not the owner of the event, new booking should be always pending.
+    // Otherwise, an owner rescheduling should be always accepted.
+    // Before comparing make sure that userId is set, otherwise undefined === undefined
+    const userReschedulingIsOwner = userId && originalRescheduledBooking?.user?.id === userId;
+    const isConfirmedByDefault =
+      (!eventType.requiresConfirmation && !paymentAppData.price) || userReschedulingIsOwner;
+
+    const attendeesData = evt.attendees.map((attendee) => {
+      //if attendee is team member, it should fetch their locale not booker's locale
+      //perhaps make email fetch request to see if his locale is stored, else
+      return {
+        name: attendee.name,
+        email: attendee.email,
+        timeZone: attendee.timeZone,
+        locale: attendee.language.locale,
+      };
+    });
+
     const newBookingData: Prisma.BookingCreateInput = {
       uid,
       responses: responses === null ? Prisma.JsonNull : responses,
@@ -977,30 +1454,7 @@ async function handler(
       metadata: reqBody.metadata,
       attendees: {
         createMany: {
-          data: [
-            ...evt.attendees.map((attendee) => {
-              //if attendee is team member, it should fetch their locale not booker's locale
-              //perhaps make email fetch request to see if his locale is stored, else
-              const retObj = {
-                name: attendee.name,
-                email: attendee.email,
-                timeZone: attendee.timeZone,
-                locale: attendee.language.locale,
-              };
-              return retObj;
-            }),
-            // Have this for now until we change the relationship between bookings & team members
-            ...(evt.team?.members
-              ? evt.team.members.map((member) => {
-                  return {
-                    email: member.email,
-                    name: member.name,
-                    timeZone: member.timeZone,
-                    locale: member.language.locale,
-                  };
-                })
-              : []),
-          ],
+          data: attendeesData,
         },
       },
       dynamicEventSlugRef,
@@ -1016,6 +1470,7 @@ async function handler(
           }
         : undefined,
     };
+
     if (reqBody.recurringEventId) {
       newBookingData.recurringEventId = reqBody.recurringEventId;
     }
@@ -1023,7 +1478,14 @@ async function handler(
       newBookingData["paid"] = originalRescheduledBooking.paid;
       newBookingData["fromReschedule"] = originalRescheduledBooking.uid;
       if (newBookingData.attendees?.createMany?.data) {
-        newBookingData.attendees.createMany.data = originalRescheduledBooking.attendees;
+        // Reschedule logic with booking with seats
+        if (eventType?.seatsPerTimeSlot && bookerEmail) {
+          newBookingData.attendees.createMany.data = attendeesData.filter(
+            (attendee) => attendee.email === bookerEmail
+          );
+        } else {
+          newBookingData.attendees.createMany.data = originalRescheduledBooking.attendees;
+        }
       }
       if (originalRescheduledBooking.recurringEventId) {
         newBookingData.recurringEventId = originalRescheduledBooking.recurringEventId;
@@ -1036,6 +1498,7 @@ async function handler(
         },
         attendees: true,
         payment: true,
+        references: true,
       },
       data: newBookingData,
     };
@@ -1074,6 +1537,8 @@ async function handler(
   let booking: (Booking & { appsStatus?: AppsStatus[] }) | null = null;
   try {
     booking = await createBooking();
+
+    // @NOTE: Add specific try catch for all subsequent async calls to avoid error
     // Sync Services
     await syncServicesUpdateWebUser(
       await prisma.user.findFirst({
@@ -1082,6 +1547,34 @@ async function handler(
       })
     );
     evt.uid = booking?.uid ?? null;
+
+    if (booking && booking.id && eventType.seatsPerTimeSlot) {
+      const currentAttendee = booking.attendees.find(
+        (attendee) => attendee.email === req.body.responses.email
+      )!;
+
+      // Save description to bookingSeat
+      const uniqueAttendeeId = uuid();
+      await prisma.bookingSeat.create({
+        data: {
+          referenceUid: uniqueAttendeeId,
+          data: {
+            description: evt.additionalNotes,
+          },
+          booking: {
+            connect: {
+              id: booking.id,
+            },
+          },
+          attendee: {
+            connect: {
+              id: currentAttendee?.id,
+            },
+          },
+        },
+      });
+      evt.attendeeSeatId = uniqueAttendeeId;
+    }
   } catch (_err) {
     const err = getErrorFromUnknown(_err);
     log.error(`Booking ${eventTypeId} failed`, "Error when saving booking to db", err.message);
@@ -1148,12 +1641,8 @@ async function handler(
     }
 
     // Use EventManager to conditionally use all needed integrations.
-    const updateManager = await eventManager.reschedule(
-      evt,
-      originalRescheduledBooking.uid,
-      booking?.id,
-      rescheduleReason
-    );
+
+    const updateManager = await eventManager.reschedule(evt, originalRescheduledBooking.uid, booking?.id);
     // This gets overridden when updating the event - to check if notes have been hidden or not. We just reset this back
     // to the default description when we are sending the emails.
     evt.description = eventType.description;
@@ -1184,8 +1673,9 @@ async function handler(
         }
       }
       if (noEmail !== true) {
+        const copyEvent = cloneDeep(evt);
         await sendRescheduledEmails({
-          ...evt,
+          ...copyEvent,
           additionalInformation: metadata,
           additionalNotes, // Resets back to the additionalNote input and not the override value
           cancellationReason: "$RCH$" + rescheduleReason, // Removable code prefix to differentiate cancellation from rescheduling for email
@@ -1461,7 +1951,10 @@ async function handler(
 
   // booking successful
   req.statusCode = 201;
-  return booking;
+  return {
+    ...booking,
+    seatReferenceUid: evt.attendeeSeatId,
+  };
 }
 
 export default handler;
@@ -1501,3 +1994,46 @@ function handleCustomInputs(
     }
   });
 }
+
+const resultBookingQuery = async (bookingId: number) => {
+  const foundBooking = await prisma.booking.findUnique({
+    where: {
+      id: bookingId,
+    },
+    select: {
+      uid: true,
+      location: true,
+      startTime: true,
+      endTime: true,
+      title: true,
+      description: true,
+      status: true,
+      responses: true,
+      user: {
+        select: {
+          name: true,
+          email: true,
+          timeZone: true,
+        },
+      },
+      eventType: {
+        select: {
+          title: true,
+          description: true,
+          currency: true,
+          length: true,
+          requiresConfirmation: true,
+          price: true,
+        },
+      },
+    },
+  });
+
+  // This should never happen but it's just typescript safe
+  if (!foundBooking) {
+    throw new Error("Internal Error.");
+  }
+
+  // Don't leak any sensitive data
+  return foundBooking;
+};
